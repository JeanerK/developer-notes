如何限流
---------------
> 限流一般是一种保护系统稳定性的一种措施。在开放API中比较常见。  
对某一用户，或指定IP，或具体到某个API，在一个具体的时间里限制请求次数。

关键词
* 熔断
* 服务降级
* 延迟处理
* 特权处理

## 主流框架的实现
首先看看主要的框架是使用，再讨论自己怎么实现

### spring-cloud-gateway

maven `pom.xml`
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
</dependency>
```
appliaction.yml
```yaml
spring:
  cloud:
    gateway:
      routes:
      - id: zzz-transfer
        uri: lb://zzz-transfer
        order: 8002
        predicates:
        - Path=/api/tengine/**
        - CacheBody={*}
        filters:
        - StripPrefix=2
        - name: RequestRateLimiter
            args:
              redis-rate-limiter.replenishRate: 1  # 允许用户每秒处理多少个请求
              redis-rate-limiter.burstCapacity: 3  # 令牌桶的容量，允许在一秒钟内完成的最大请求数
              key-resolver: "#{@hostNameKeyResolver}" #SPEL表达式去的对应的bean
      enabled: true
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}

```

```java
    /**
     * IP 限流
     * @return
     */
    @Bean
    @Primary
    KeyResolver hostNameKeyResolver() {
        return exchange -> Mono.just(exchange.getRequest().getRemoteAddress().getHostName());
    }

    /**
     * API 地址限流
     * @return
     */
    @Bean
    KeyResolver apiKeyResolver() {
        return exchange -> Mono.just(exchange.getRequest().getPath().value());
    }
```


### Alibaba Sentinel
Spring Cloud Netflix 诸多组件不在更新维护后 Spring Cloud也正式加入了[spring-cloud-alibaba](https://spring.io/projects/spring-cloud-alibaba) 
[Sentinel](https://github.com/alibaba/spring-cloud-alibaba#components)就是其中一员，它把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性

pom.xml
```xml
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
        </dependency>
```

#### 配置方式

* 基于sentinel-dashboard 界面化配置

    下载 sentinel-dashboard https://github.com/alibaba/Sentinel/releases
    ```shell
    java -jar sentinel-dashboard.jar --server.port=8080
    
    可能在sentinel dashboard上不显示，请求一下个个服务试试
    ```
    
    application.yml
    ```
    spring:
      application:
        name: zzz-gateway
      cloud:
        nacos:
          discovery:
            server-addr: z.com:8848
        sentinel:
          transport:
            dashboard: z.com:8080
          enabled: true
    ```
* 基于nacos config

    application.yml
    ```
    spring:
      application:
        name: zzz-gateway
      cloud:
        nacos:
          discovery:
            server-addr: ifuture.pro:8848
          config:
            server-addr: ifuture.pro:8848
            file-extension: yaml
        sentinel:
          transport:
            dashboard: ifuture.pro:8080
          datasource:
              ds:
                nacos:
                  server-addr: ifuture.pro:8848
                  dataId: spring-cloud-sentinel-nacos
                  groupId: DEFAULT_GROUP
                  rule-type: flow
                  namespace: zzzgateway
    ```  
    
    ```yaml
    - resource: "/api"
      limitApp: default
      grade: 1
      count: 1
      strategy: 0
      controlBehavior: 0
      clusterMode: true
      
      resource：资源名，即限流规则的作用对象。
      limitApp：流控针对的调用来源，若为 default 则不区分调用来源。
      grade：限流阈值类型，QPS 或线程数模式，0代表根据并发数量来限流，1代表根据QPS来进行流量控制。
      count：限流阈值
      strategy：判断的根据是资源自身，还是根据其它关联资源 (refResource)，还是根据链路入口
      controlBehavior：流控效果（直接拒绝 / 排队等待 / 慢启动模式）
      clusterMode：是否为集群模式
    ```  
* 基于代码
    https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8
    
    
    
## 自己实现

### 计数器
系统维护一个计数器，来一个请求就加1，请求处理完成就减1，当计数器大于指定的阈值，就拒绝新的请求。  
基于这个简单的方法，可以再延伸出一些高级功能，比如阈值可以不是固定值，是动态调整的。另外，还可以有多组计数器分别管理不同的服务，以保证互不影响等。

### 队列
就是基于FIFO队列，所有请求都进入队列，后端程序从队列中取出待处理的请求依次处理。  
基于队列的方法，也可以延伸出更多的玩法来，比如可以设置多个队列以配置不同的优先级。

### **令牌桶**
首先还是要基于一个队列，请求放到队列里面。但除了队列以外，还要设置一个令牌桶，另外有一个脚本以持续恒定的速度往令牌桶里面放令牌，后端处理程序每处理一个请求就必须从桶里拿出一个令牌，如果令牌拿完了，那就不能处理请求了。我们可以控制脚本放令牌的速度来达到控制后端处理的速度，以实现动态流控。
* 一个固定容量的桶。如：每分钟能请求的最大量
* 一个永续线程以匀速的方式将令牌放入桶中，超过容量丢弃
* 有请求了，将桶内令牌取出，如果没有足够的令牌则限流